/*
 * Project: Three-Phase Grid-Connected Inverter (GCI) Control
 * Platform: TI C2000 F28379D LaunchPad
 * Author: ee.rohan
 * Description:
 * This program implements a full digital control stack for a 10kVA GCI.
 * It includes:
 * 1. SRF-PLL for grid synchronization.
 * 2. Decoupled Inner Current Loop (dq-frame) for fast regulation.
 * 3. Outer Power Loop for Active (P) and Reactive (Q) power control.
 * 4. Processor-in-the-Loop (PIL) plant model of the inverter and L-filter.
 */

#include "F28x_Project.h"
#include "math.h"

// --- System Parameters ---
float line_freq = 50;           // Nominal Grid Frequency (Hz)
float theta = 0;                // Grid Voltage Angle (Simulated)
float sampling_time = 100e-6;   // Sampling Period (Ts) = 1/10kHz

// --- Grid & Voltage Variables ---
float Vm = 325;                 // Peak Phase Voltage (415V L-L)
float va = 0, vb = 0, vc = 0;   // Instantaneous Grid Voltages (abc)
float vd = 0, vq = 0;           // Grid Voltages in dq-frame

// --- Current & Power Variables ---
float ia = 0, ib = 0, ic = 0;   // Instantaneous Inverter Currents (abc)
float id = 0, iq = 0;           // Currents in dq-frame
float pdq = 0, qdq = 0;         // Calculated Active & Reactive Power

// --- PLL Variables ---
// Using SRF-PLL structure with Tustin discretized PI controller
float f;                        // Estimated Grid Frequency
float delta_f = 0, delta_f_pre = 0; // PI Controller Output (Frequency Deviation)
float vq_pre = 0;               // Previous error sample for Tustin
float thetaPLL = 0, thetaPLL1 = 0, thetaPLL_pre = 0; // Estimated Phase Angle
float f_pre = 0;
float kp_pll = 0.687, ki_pll = 77.47; // PLL PI Gains

// --- Plant Model Parameters (L-Filter) ---
float L = 50e-3;                // Filter Inductance (30mH or 50mH)
float rL = 0.1;                 // Inductor Resistance
float omegaL;                   // Grid Impedance (wL) for decoupling

// --- Controller Coefficients (Tustin/Bilinear Transform) ---
// b0-b1: PLL PI | b2-b3: Plant Model | b4-b5: Power Loop | b6-b7: Q Loop | b8-b9: Current Loop
float b0, b1, b2, b3, b4, b5, b6, b7, b8, b9;

// --- Controller References & State Variables ---
float refa = 0, refb = 0, refc = 0; // Normalized Duty Cycles (0-1)
float vdc = 800;                // DC Link Voltage
float vao = 0, vbo = 0, vco = 0, vno = 0; // Inverter Pole & Neutral Voltages
float vla = 0, vlb = 0, vlc = 0; // Inductor Voltages
float vla_pre = 0, vlb_pre = 0, vlc_pre = 0; // Previous States for Integration

float pref = 3000, qref = 0;    // Power References (Watts, VARs)

// --- PI Controller Errors & Integrators ---
float error_p = 0, error_q = 0, error_id = 0, error_iq = 0;
float error_p_pre = 0, error_q_pre = 0, error_id_pre = 0, error_iq_pre = 0;
float idref = 0, iqref = 0;     // Current References generated by Power Loop
float ud = 0, uq = 0;           // Current Controller Output (Voltage Ref)

// --- PI Gains ---
float kp_p = 2e-3, ki_p = 1;    // Active Power Loop Gains
float kp_q = 2e-3, ki_q = 1;    // Reactive Power Loop Gains
float kp_i = 200, ki_i = 50;    // Current Loop Gains

// --- Modulation Variables ---
float md, mq, ma, mb, mc;       // Modulation Indices

// --- DAC Debugging ---
Uint16 dac1 = 0, dac2 = 0;

// --- Function Prototypes ---
extern interrupt void epwm1_isr(void);
void Gpio_select(void);
void epwm1_int_setup(void);
void setup_epwm(void);
void initdaca(void);
void inverter (void); // PIL Plant Model

// ============================================================================
// Main Code
// ============================================================================
void main(void){
    InitSysCtrl(); // Initialize System Control (clocks, watchdog, etc.)
    DINT;          // Disable Interrupts globally

    // Hardware Setup
    Gpio_select();
    setup_epwm();
    epwm1_int_setup();
    initdaca();

    // --- Coefficient Calculation for Tustin Discretization ---
    // Formula: H(z) = Kp + Ki*(Ts/2)*(z+1)/(z-1)
    
    // PLL Loop Coefficients
    b0 = (2*kp_pll + ki_pll*sampling_time)/2;
    b1 = (ki_pll*sampling_time - 2*kp_pll)/2;

    // Plant Model (RL Circuit) Discrete Coefficients
    // V = L(di/dt) + Ri -> Discretized difference equation
    b2 = (2 * L + rL * sampling_time)/sampling_time;
    b3 = (rL * sampling_time - 2 * L)/sampling_time;

    // Active Power PI Coefficients
    b4 = (2 * kp_p + ki_p * sampling_time)/2;
    b5 = (ki_p * sampling_time - 2 * kp_p)/2;

    // Reactive Power PI Coefficients
    b6 = (2 * kp_q + ki_q * sampling_time)/2;
    b7 = (ki_q * sampling_time - 2 * kp_q)/2;

    // Current Loop PI Coefficients
    b8 = (2 * kp_i + ki_i * sampling_time)/2;
    b9 = (ki_i * sampling_time - 2 * kp_i)/2;

    // Grid Impedance for Decoupling
    omegaL = 2 * M_PI * line_freq * L;

    while(1){
        // Infinite Loop: Control happens in ISR
    }
}

// ============================================================================
// GPIO Configuration
// ============================================================================
void Gpio_select(void){
    EALLOW;
    // Enable PWM pins on GPIO 0-5 (EPWM1A/B, EPWM2A/B, EPWM3A/B)
    GpioCtrlRegs.GPAMUX1.bit.GPIO0 = 1;
    GpioCtrlRegs.GPAMUX1.bit.GPIO1 = 1;
    GpioCtrlRegs.GPAMUX1.bit.GPIO2 = 1;
    GpioCtrlRegs.GPAMUX1.bit.GPIO3 = 1;
    GpioCtrlRegs.GPAMUX1.bit.GPIO4 = 1;
    GpioCtrlRegs.GPAMUX1.bit.GPIO5 = 1;
    EDIS;
}

// ============================================================================
// ePWM Configuration
// ============================================================================
void setup_epwm(void){
    // --- EPWM 1 Setup (Master) ---
    EPwm1Regs.TBCTL.bit.CLKDIV = 1;
    EPwm1Regs.TBCTL.bit.HSPCLKDIV = 1;
    EPwm1Regs.TBCTL.bit.CTRMODE = 0;       // Up-count mode
    EPwm1Regs.TBPRD = 2500;                // Period = 2500 ticks (10kHz @ 100MHz/4)
    EPwm1Regs.CMPA.bit.CMPA = 1250;        // 50% initial duty
    EPwm1Regs.AQCTLA.all = 0x0012;         // Action Qualifier setup
    EPwm1Regs.TBCTL.bit.SYNCOSEL = 1;      // Master Sync Output
    
    // Interrupt Configuration
    EPwm1Regs.ETSEL.bit.INTSELCMP = 0;
    EPwm1Regs.ETSEL.bit.INTEN = 1;         // Enable Interrupt
    EPwm1Regs.ETSEL.bit.INTSEL = 2;        // Interrupt on Period match
    EPwm1Regs.ETPS.bit.INTPRD = 1;         // Generate interrupt on 1st event
    EPwm1Regs.ETCLR.bit.INT = 1;           // Clear Flag

    // --- EPWM 2 Setup (Slave) ---
    EPwm2Regs.TBCTL.bit.CLKDIV = 1;
    EPwm2Regs.TBCTL.bit.HSPCLKDIV = 1;
    EPwm2Regs.TBCTL.bit.CTRMODE = 0;
    EPwm2Regs.TBPRD = 2500;
    EPwm2Regs.CMPA.bit.CMPA = 1250;
    EPwm2Regs.AQCTLA.all = 0x0012;
    EPwm2Regs.TBCTL.bit.SYNCOSEL = 0;      // Slave Sync Input

    // --- EPWM 3 Setup (Slave) ---
    EPwm3Regs.TBCTL.bit.CLKDIV = 1;
    EPwm3Regs.TBCTL.bit.HSPCLKDIV = 1;
    EPwm3Regs.TBCTL.bit.CTRMODE = 0;
    EPwm3Regs.TBPRD = 2500;
    EPwm3Regs.CMPA.bit.CMPA = 1250;
    EPwm3Regs.AQCTLA.all = 0x0012;
    EPwm3Regs.TBCTL.bit.SYNCOSEL = 0;
}

// ============================================================================
// Interrupt Setup
// ============================================================================
void epwm1_int_setup(void){
    InitPieCtrl();
    IER = 0x0000;
    IFR = 0x0000;
    InitPieVectTable();
    EALLOW;
    PieVectTable.EPWM1_INT = &epwm1_isr; // Map ISR function
    EDIS;
    IER |= M_INT3;                       // Enable CPU INT3
    PieCtrlRegs.PIEIER3.bit.INTx1 = 1;   // Enable PIE Group 3, INT 1 (EPWM1)
    EINT;
    ERTM;
}

// ============================================================================
// DAC Setup
// ============================================================================
void initdaca(void){
    EALLOW;
    // DAC A Setup
    DacaRegs.DACCTL.bit.DACREFSEL = 1;   // Use ADC VREFHI
    DacaRegs.DACCTL.bit.LOADMODE = 0;    // Load on SYSCLK
    DacaRegs.DACOUTEN.bit.DACOUTEN = 1;  // Enable Output
    DacaRegs.DACVALS.bit.DACVALS = dac1;
    DELAY_US(10);
    
    // DAC B Setup
    DacbRegs.DACCTL.bit.DACREFSEL = 1;
    DacbRegs.DACCTL.bit.LOADMODE = 0;
    DacbRegs.DACOUTEN.bit.DACOUTEN = 1;
    DacbRegs.DACVALS.bit.DACVALS = dac2;
    DELAY_US(10);
    EDIS;
}

// ============================================================================
// Main Control ISR (Runs at 10kHz)
// ============================================================================
extern interrupt void epwm1_isr(void){
    // 1. Grid Voltage Simulation (Open Loop Grid)
    theta = theta + (2*M_PI*line_freq*sampling_time);
    va = Vm*__sin(theta);
    vb = Vm*__sin(theta - 2*M_PI/3);
    vc = Vm*__sin(theta - 4*M_PI/3);

    // 2. Run Plant Model (PIL)
    // Uses previous cycle's duty cycle to calculate current response
    inverter();

    // 3. SRF-PLL: Park Transform (ABC to DQ) for Voltage
    // Vd aligned with voltage vector, Vq should be regulated to 0
    vd = (2.0/3.0)*((va*__sin(thetaPLL))+(vb*__sin(thetaPLL - 2*M_PI/3))+(vc*__sin(thetaPLL - 4*M_PI/3)));
    vq = (2.0/3.0)*((va*__cos(thetaPLL))+(vb*__cos(thetaPLL - 2*M_PI/3))+(vc*__cos(thetaPLL - 4*M_PI/3)));

    // 4. PLL Controller (Tustin PI)
    delta_f = delta_f_pre + b0*vq + b1*vq_pre;
    vq_pre = vq;
    delta_f_pre = delta_f;

    // PLL Integration (Frequency -> Angle)
    f = delta_f + line_freq; // Add nominal 50Hz
    thetaPLL1 = thetaPLL_pre + M_PI*sampling_time*(f + f_pre);
    
    // Angle Wrapping (0 to 2*PI)
    thetaPLL = (thetaPLL1 <= 2*M_PI)*thetaPLL1; 
    thetaPLL_pre = thetaPLL;
    f_pre = f;

    // 5. Current Measurement Transform (ABC to DQ)
    id = (2.0/3.0)*((ia*__sin(thetaPLL))+(ib*__sin(thetaPLL - 2*M_PI/3))+(ic*__sin(thetaPLL - 4*M_PI/3)));
    iq = (2.0/3.0)*((ia*__cos(thetaPLL))+(ib*__cos(thetaPLL - 2*M_PI/3))+(ic*__cos(thetaPLL - 4*M_PI/3)));

    // 6. Power Calculation
    pdq = 1.5 * vd * id;
    qdq = 1.5 * vd * iq;

    // 7. Outer Loop: Power Control (P and Q)
    // Active Power PI
    error_p = pref - pdq;
    idref = idref + (b4 * error_p) + (b5 * error_p_pre);
    error_p_pre = error_p;

    // Reactive Power PI
    error_q = qref - qdq;
    iqref = iqref + (b6 * error_q) + (b7 * error_q_pre);
    error_q_pre = error_q;

    // 8. Inner Loop: Current Control (Id and Iq)
    // D-Axis Current PI
    error_id = idref - id;
    ud = ud + (b8 * error_id) + (b9 * error_id_pre);
    error_id_pre = error_id;

    // Q-Axis Current PI
    error_iq = iqref - iq;
    uq = uq + (b8 * error_iq) + (b9 * error_iq_pre);
    error_iq_pre = error_iq;

    // 9. Decoupling and Grid Feedforward
    // Improves transient response by decoupling d and q axes
    md = (((ud - iq * omegaL) + vd)*2)/vdc;
    mq = (((uq + id * omegaL) + vq)*2)/vdc;

    // 10. Inverse Park Transform (DQ to ABC)
    // Generates reference modulation signals
    ma = __sin(thetaPLL) * md + __cos(thetaPLL) * mq;
    mb = __sin(thetaPLL - 2*M_PI/3) * md + __cos(thetaPLL - 2*M_PI/3) * mq;
    mc = __sin(thetaPLL - 4*M_PI/3) * md + __cos(thetaPLL - 4*M_PI/3) * mq;

    // 11. PWM Generation (Normalize to 0-1 range)
    refa = (ma + 1)/2;
    refb = (mb + 1)/2;
    refc = (mc + 1)/2;

    // Update PWM Registers
    EPwm1Regs.CMPA.bit.CMPA = refa * 2500;
    EPwm2Regs.CMPA.bit.CMPA = refb * 2500;
    EPwm3Regs.CMPA.bit.CMPA = refc * 2500;

    // 12. DAC Output for Debugging (View on Scope)
    dac1 = ((va + 325)/(2 * 325))*4095; // Scale Grid V to 0-3.3V
    dac2 = ((ia + 10)/(2 * 10))*4095;   // Scale Grid I to 0-3.3V
    DacaRegs.DACVALS.bit.DACVALS = dac1;
    DacbRegs.DACVALS.bit.DACVALS = dac2;

    // Acknowledge Interrupt
    PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;
    EPwm1Regs.ETCLR.bit.INT = 1;
}

// ============================================================================
// Inverter Plant Model (Processor-in-Loop)
// ============================================================================
void inverter (void){
    // Calculate actual Inverter Pole Voltages
    vao = vdc * refa;
    vbo = vdc * refb;
    vco = vdc * refc;
    
    // Calculate Neutral Voltage
    vno = (vao + vbo + vco)/3;
    
    // Voltage across the L-Filter
    vla = vao - va - vno;
    vlb = vbo - vb - vno;
    vlc = vco - vc - vno;

    // Discrete integration of Inductor Equation: V = L(di/dt) + iR
    // Updates currents based on voltage difference between Inverter and Grid
    ia = (-b3 * ia + (vla + vla_pre))/b2;
    ib = (-b3 * ib + (vlb + vlb_pre))/b2;
    ic = (-b3 * ic + (vlc + vlc_pre))/b2;
    
    // Store states for next cycle
    vla_pre = vla;
    vlb_pre = vlb;
    vlc_pre = vlc;
}